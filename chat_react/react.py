# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_react.ipynb.

# %% auto 0
__all__ = ['CancelCallTool', 'CancelStep', 'CancelLLM', 'CancelParse', 'CancelRun', 'LogMessagesCB', 'CostCB', 'React',
           'calculator', 'send_to_user', 'finish']

# %% ../nbs/01_react.ipynb 2
import re

from fastcore.all import *

from .core import *

# %% ../nbs/01_react.ipynb 4
class CancelCallTool(Exception): pass
class CancelStep(Exception): pass
class CancelLLM(Exception): pass
class CancelParse(Exception): pass
class CancelRun(Exception): pass

# %% ../nbs/01_react.ipynb 6
class LogMessagesCB:
    def after_llm(self, bot, out): print(out[0])
    def after_call_tool(self, bot, out): print(f'Output: {out}')

# %% ../nbs/01_react.ipynb 7
class CostCB:
    def __init__(self, cost=0): store_attr()
    def after_llm(self, bot, args):
        print(f'Cost: ${args[1]}')
        self.cost += args[1]
    def after_run(self, bot, cost):
        print(f'Total cost: ${self.cost}')

# %% ../nbs/01_react.ipynb 8
class React:
    def __init__(self, prompt=None, examples=[], tools=[], cbs=[], max_turns=10, end_tool='finish'):
        store_attr()
        if not prompt:
            prompt = self.base_prompt(tools)
        self.messages = [hm(prompt)] + examples + [aim("Though: I have to greet the user\nAction: send_to_user[Hi, I am an AI, how can I help you today?]")]
    
    def base_prompt(self, tools): 
        prompt = "You can use the following tools:\n" + '\n'.join([f"- {tool.__name__}" for tool in tools])
        prompt += "Before using a tool think about what you want to do and write it down in a sentence.\n"
        prompt += "Use the following format:\nThougth: <your thought>\nAction: <tool_name>[<tool_input>]\n\n"
        return prompt
    
    def llm(self, messages): return chat_create(messages)

    def with_cbs(self, name, exception, *args, **kwargs):
        for cb in self.cbs:
            if hasattr(cb, f'before_{name}'): getattr(cb, f'before_{name}')(self, *args, **kwargs)
        try: result = getattr(self, name)(*args, **kwargs) 
        except exception as e:
            for cb in self.cbs:
                if hasattr(cb, f'after_cancel_{name}'): getattr(cb, f'after_cancel_{name}')(self, *args, **kwargs)
            return
        for cb in self.cbs:
            if hasattr(cb, f'after_{name}'): getattr(cb, f'after_{name}')(self, result)
        return result
    
    def __call__(self, query):
        return self.with_cbs('run', CancelRun, self.messages + [hm(f'Output: {query}')])
    
    def run(self, messages):
        for i in range(self.max_turns):
            messages, tool_name, tool_input = self.with_cbs('step', CancelStep, messages)
            if tool_name == self.end_tool: break
        return messages, tool_name, tool_input


    def step(self, messages):
        out, cost = self.with_cbs('llm', CancelLLM, messages)
        messages.append(aim(out))
        tool_name, tool_input = self.with_cbs('parse_output', CancelParse, out)
        if tool_name != self.end_tool:
            tool_output = self.with_cbs('call_tool', CancelCallTool, tool_name, tool_input)
            messages.append(hm(f"Output: {tool_output}"))
        return messages, tool_name, tool_input
    
    def parse_output(self, text):
        """Parses text into action and action_input."""
        i = text.find('Action:')
        m = re.match(r"Action: (?P<tool_name>.*)\[(?P<tool_input>.*)\]", text[i:], re.DOTALL)
        if not m: raise Exception
        return m.group(1, 2)

    def call_tool(self, tool_name, tool_input):
        for tool in self.tools: 
            if tool.__name__ == tool_name: return tool(tool_input)

# %% ../nbs/01_react.ipynb 9
def calculator(s):
    """python interpreter"""
    return eval(s)

# %% ../nbs/01_react.ipynb 10
def send_to_user(m):
    """ask a question to the user"""
    print(m)
    return input

# %% ../nbs/01_react.ipynb 11
def finish():
    """send your final answer to the user"""
